)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
## Here with bug currently
quad <- aghq::marginal_laplace_tmb(ff, k = Inference_control$aghq_k, startingvalue = 0)
}
else if(length(fixed) > 0 & length(frailty) == 0 & length(RW2) == 0){
## Create X design
X <- as(as.matrix(data[fixed]), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Differencing matrix
D = D,
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
betaprec = fixed_control$betaprec
)
tmbparams <- list(
W = rep(0,ncol(X))
)
ff <- TMB::MakeADFun(
data = c(model = "fixed", tmbdat),
parameters = tmbparams,
# random = "W",
DLL = "abcoxp_TMBExports",
silent = T
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
opt <- nlminb(start = ff$par, objective = ff$fn, gradient = ff$gr, hessian = ff$he,
control = list(eval.max = 20000, iter.max = 20000))
prec_matrix <- forceSymmetric(ff$he(opt$par))
## also with Bug currently..
return(list(mean = opt$par, prec = as.matrix(prec_matrix), opt = opt))
}
else if(length(fixed) == 0 & length(frailty) == 0 & length(RW2) == 1){
## Create B2 design
## Create P2 precision
u2 <- as.numeric(data[RW2][,1])
B2 <- RW2_design_comp(x = u2, r = RW2_control$r)
P2 <- RW2_prec_comp(x = u2, r = RW2_control$r, diag_noise = RW2_control$diag_noise)
tmbdat <- list(
# Design matrix
B2 = B2,
# Penalty matrix
P2 = P2,
# Differencing matrix
D = D,
# Log determinant of penalty matrix (without the sigma part)
logP2det = as.numeric(determinant(P2,logarithm = TRUE)$modulus),
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
u = RW2_control$u,
alpha = RW2_control$alpha
)
tmbparams <- list(
W = rep(0, ncol(B2)),
theta = 0
)
ff <- TMB::MakeADFun(
data = c(model = "smooth", tmbdat),
parameters = tmbparams,
random = "W",
DLL = "abcoxp_TMBExports",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
quad <- aghq::marginal_laplace_tmb(ff, k = Inference_control$aghq_k, c(0))
}
else{
stop("Model does not have a TMB template yet, need to manually implement.")
}
}
#
ff <- abcoxp(data = Leuk, times = "time", cens = "cens", fixed = "tpi",
fixed_control = list(betaprec = .1))
ff$mean
abcoxp <- function(data, times, cens, fixed = NULL, frailty = NULL, RW2 = NULL,
fixed_control = list(betaprec = .001), frailty_control = list(alpha = 0.5, u = 1),
RW2_control = list(alpha = 0.5, u = 1, r = 50, diag_noise = 0.0001),
Inference_control = list(aghq_k = 4)){
data <- cbind(data[times], data[cens], data[fixed], data[frailty], data[RW2])
colnames(data) <- c("times", "cens", fixed, frailty, RW2)
data <- dplyr::arrange(data, by = times)
data$ranks <- rank(data$times, ties.method = "min")
n <- nrow(data)
D <- cbind(Matrix::Matrix(1,n-1,1),Matrix::Diagonal(n-1,-1))
if(length(fixed) > 0 & length(frailty) == 1 & length(RW2) == 1){
## Create X, B1, B2 design
## Create P2 precision
X <- as(as.matrix(data[fixed]), "dgTMatrix")
u1 <- as.numeric(data[frailty][,1])
B1 <- Matrix::Diagonal(n = n)[match(u1,unique(u1)),order(unique(u1))]
u2 <- as.numeric(data[RW2][,1])
B2 <- RW2_design_comp(x = u2, r = RW2_control$r)
P2 <- RW2_prec_comp(x = u2, r = RW2_control$r, diag_noise = RW2_control$diag_noise)
tmbdat <- list(
# Design matrix
X = X,
B1 = B1,
B2 = B2,
# Penalty matrix
P2 = P2,
# Differencing matrix
D = D,
# Log determinant of penalty matrix (without the sigma part)
logP2det = as.numeric(determinant(P2,logarithm = TRUE)$modulus),
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
u1 = frailty_control$u,
alpha1 = frailty_control$alpha,
u2 = RW2_control$u,
alpha2 = RW2_control$alpha,
betaprec = fixed_control$betaprec
)
tmbparams <- list(
W = rep(0,ncol(B1) + ncol(B2) + ncol(X)),
theta1 = 0, # -2log(sigma)
theta2 = 0
)
ff <- TMB::MakeADFun(
data = c(model = "fixed_smooth_frailty", tmbdat),
parameters = tmbparams,
random = "W",
DLL = "abcoxp_TMBExports",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
quad <- aghq::marginal_laplace_tmb(ff, k = Inference_control$aghq_k, c(0,0))
}
else if(length(fixed) > 0 & length(frailty) == 1 & length(RW2) == 0){
## Create X, B1 design
X <- as(as.matrix(data[fixed]), "dgTMatrix")
u1 <- as.numeric(data[frailty][,1])
B1 <- Matrix::Diagonal(n = n)[match(u1,unique(u1)),order(unique(u1))]
tmbdat <- list(
# Design matrix
X = X,
B1 = B1,
# Differencing matrix
D = D,
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
u = frailty_control$u,
alpha = frailty_control$alpha,
betaprec = fixed_control$betaprec
)
tmbparams <- list(
W = rep(0,ncol(B1) + ncol(X)),
theta = 0 # -2log(sigma)
)
ff <- TMB::MakeADFun(
data = c(model = "fixed_frailty", tmbdat),
parameters = tmbparams,
random = "W",
DLL = "abcoxp_TMBExports",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
quad <- aghq::marginal_laplace_tmb(ff, k = Inference_control$aghq_k, c(0))
}
else if(length(fixed) > 0 & length(frailty) == 0 & length(RW2) == 1){
## Create X, B2 design
## Create P2 precision
X <- as(as.matrix(data[fixed]), "dgTMatrix")
u2 <- as.numeric(data[RW2][,1])
B2 <- RW2_design_comp(x = u2, r = RW2_control$r)
P2 <- RW2_prec_comp(x = u2, r = RW2_control$r, diag_noise = RW2_control$diag_noise)
tmbdat <- list(
# Design matrix
X = X,
B2 = B2,
# Penalty matrix
P2 = P2,
# Differencing matrix
D = D,
# Log determinant of penalty matrix (without the sigma part)
logP2det = as.numeric(determinant(P2,logarithm = TRUE)$modulus),
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
u = RW2_control$u,
alpha = RW2_control$alpha,
betaprec = fixed_control$betaprec
)
tmbparams <- list(
W = rep(0,ncol(B2) + ncol(X)),
theta = 0
)
ff <- TMB::MakeADFun(
data = c(model = "fixed_smooth", tmbdat),
parameters = tmbparams,
random = "W",
DLL = "abcoxp_TMBExports",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
## Here with bug currently
quad <- aghq::marginal_laplace_tmb(ff, k = Inference_control$aghq_k, startingvalue = 0)
}
else if(length(fixed) > 0 & length(frailty) == 0 & length(RW2) == 0){
## Create X design
X <- as(as.matrix(data[fixed]), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Differencing matrix
D = D,
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
betaprec = fixed_control$betaprec
)
tmbparams <- list(
W = rep(0,ncol(X))
)
ff <- TMB::MakeADFun(
data = c(model = "fixed", tmbdat),
parameters = tmbparams,
# random = "W",
DLL = "abcoxp_TMBExports",
silent = T
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
opt <- nlminb(start = ff$par, objective = ff$fn, gradient = ff$gr, hessian = ff$he,
control = list(eval.max = 20000, iter.max = 20000))
prec_matrix <- forceSymmetric(ff$he(opt$par))
## also with Bug currently..
return(list(mean = opt$par, prec = as.matrix(prec_matrix), opt = opt))
}
else if(length(fixed) == 0 & length(frailty) == 0 & length(RW2) == 1){
## Create B2 design
## Create P2 precision
u2 <- as.numeric(data[RW2][,1])
B2 <- RW2_design_comp(x = u2, r = RW2_control$r)
P2 <- RW2_prec_comp(x = u2, r = RW2_control$r, diag_noise = RW2_control$diag_noise)
tmbdat <- list(
# Design matrix
B2 = B2,
# Penalty matrix
P2 = P2,
# Differencing matrix
D = D,
# Log determinant of penalty matrix (without the sigma part)
logP2det = as.numeric(determinant(P2,logarithm = TRUE)$modulus),
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
u = RW2_control$u,
alpha = RW2_control$alpha
)
tmbparams <- list(
W = rep(0, ncol(B2)),
theta = 0
)
ff <- TMB::MakeADFun(
data = c(model = "smooth", tmbdat),
parameters = tmbparams,
random = "W",
DLL = "abcoxp_TMBExports",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
quad <- aghq::marginal_laplace_tmb(ff, k = Inference_control$aghq_k, c(0))
}
else{
stop("Model does not have a TMB template yet, need to manually implement.")
}
}
#
ff <- abcoxp(data = Leuk, times = "time", cens = "cens", fixed = "age",
fixed_control = list(betaprec = .1))
ff
colnames(Leuk)
a <- abcoxp(data = Leuk, times = "time", cens = "cens", fixed = "age", RW2 = "tpi")
a <- abcoxp(data = Leuk, times = "time", cens = "cens", fixed = "age", RW2 = "tpi")
abcoxp <- function(data, times, cens, fixed = NULL, frailty = NULL, RW2 = NULL,
fixed_control = list(betaprec = .001), frailty_control = list(alpha = 0.5, u = 1),
RW2_control = list(alpha = 0.5, u = 1, r = 50, diag_noise = 0.0001),
Inference_control = list(aghq_k = 4)){
data <- cbind(data[times], data[cens], data[fixed], data[frailty], data[RW2])
colnames(data) <- c("times", "cens", fixed, frailty, RW2)
data <- dplyr::arrange(data, by = times)
data$ranks <- rank(data$times, ties.method = "min")
n <- nrow(data)
D <- cbind(Matrix::Matrix(1,n-1,1),Matrix::Diagonal(n-1,-1))
if(length(fixed) > 0 & length(frailty) == 1 & length(RW2) == 1){
## Create X, B1, B2 design
## Create P2 precision
X <- as(as.matrix(data[fixed]), "dgTMatrix")
u1 <- as.numeric(data[frailty][,1])
B1 <- Matrix::Diagonal(n = n)[match(u1,unique(u1)),order(unique(u1))]
u2 <- as.numeric(data[RW2][,1])
B2 <- RW2_design_comp(x = u2, r = RW2_control$r)
P2 <- RW2_prec_comp(x = u2, r = RW2_control$r, diag_noise = RW2_control$diag_noise)
tmbdat <- list(
# Design matrix
X = X,
B1 = B1,
B2 = B2,
# Penalty matrix
P2 = P2,
# Differencing matrix
D = D,
# Log determinant of penalty matrix (without the sigma part)
logP2det = as.numeric(determinant(P2,logarithm = TRUE)$modulus),
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
u1 = frailty_control$u,
alpha1 = frailty_control$alpha,
u2 = RW2_control$u,
alpha2 = RW2_control$alpha,
betaprec = fixed_control$betaprec
)
tmbparams <- list(
W = rep(0,ncol(B1) + ncol(B2) + ncol(X)),
theta1 = 0, # -2log(sigma)
theta2 = 0
)
ff <- TMB::MakeADFun(
data = c(model = "fixed_smooth_frailty", tmbdat),
parameters = tmbparams,
random = "W",
DLL = "abcoxp_TMBExports",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
quad <- aghq::marginal_laplace_tmb(ff, k = Inference_control$aghq_k, c(0,0))
}
else if(length(fixed) > 0 & length(frailty) == 1 & length(RW2) == 0){
## Create X, B1 design
X <- as(as.matrix(data[fixed]), "dgTMatrix")
u1 <- as.numeric(data[frailty][,1])
B1 <- Matrix::Diagonal(n = n)[match(u1,unique(u1)),order(unique(u1))]
tmbdat <- list(
# Design matrix
X = X,
B1 = B1,
# Differencing matrix
D = D,
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
u = frailty_control$u,
alpha = frailty_control$alpha,
betaprec = fixed_control$betaprec
)
tmbparams <- list(
W = rep(0,ncol(B1) + ncol(X)),
theta = 0 # -2log(sigma)
)
ff <- TMB::MakeADFun(
data = c(model = "fixed_frailty", tmbdat),
parameters = tmbparams,
random = "W",
DLL = "abcoxp_TMBExports",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
quad <- aghq::marginal_laplace_tmb(ff, k = Inference_control$aghq_k, c(0))
}
else if(length(fixed) > 0 & length(frailty) == 0 & length(RW2) == 1){
## Create X, B2 design
## Create P2 precision
X <- as(as.matrix(data[fixed]), "dgTMatrix")
u2 <- as.numeric(data[RW2][,1])
B2 <- RW2_design_comp(x = u2, r = RW2_control$r)
P2 <- RW2_prec_comp(x = u2, r = RW2_control$r, diag_noise = RW2_control$diag_noise)
tmbdat <- list(
# Design matrix
X = X,
B2 = B2,
# Penalty matrix
P2 = P2,
# Differencing matrix
D = D,
# Log determinant of penalty matrix (without the sigma part)
logP2det = as.numeric(determinant(P2,logarithm = TRUE)$modulus),
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
u = RW2_control$u,
alpha = RW2_control$alpha,
betaprec = fixed_control$betaprec
)
tmbparams <- list(
W = rep(0,ncol(B2) + ncol(X)),
theta = 0
)
ff <- TMB::MakeADFun(
data = c(model = "fixed_smooth", tmbdat),
parameters = tmbparams,
random = "W",
DLL = "abcoxp_TMBExports",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
## Here with bug currently
quad <- aghq::marginal_laplace_tmb(ff, k = Inference_control$aghq_k, startingvalue = 0)
}
else if(length(fixed) > 0 & length(frailty) == 0 & length(RW2) == 0){
## Create X design
X <- as(as.matrix(data[fixed]), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Differencing matrix
D = D,
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
betaprec = fixed_control$betaprec
)
tmbparams <- list(
W = rep(0,ncol(X))
)
ff <- TMB::MakeADFun(
data = c(model = "fixed", tmbdat),
parameters = tmbparams,
# random = "W",
DLL = "abcoxp_TMBExports",
silent = T
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
opt <- nlminb(start = ff$par, objective = ff$fn, gradient = ff$gr, hessian = ff$he,
control = list(eval.max = 20000, iter.max = 20000))
prec_matrix <- forceSymmetric(ff$he(opt$par))
return(list(mean = opt$par, prec = as.matrix(prec_matrix), opt = opt))
}
else if(length(fixed) == 0 & length(frailty) == 0 & length(RW2) == 1){
## Create B2 design
## Create P2 precision
u2 <- as.numeric(data[RW2][,1])
B2 <- RW2_design_comp(x = u2, r = RW2_control$r)
P2 <- RW2_prec_comp(x = u2, r = RW2_control$r, diag_noise = RW2_control$diag_noise)
tmbdat <- list(
# Design matrix
B2 = B2,
# Penalty matrix
P2 = P2,
# Differencing matrix
D = D,
# Log determinant of penalty matrix (without the sigma part)
logP2det = as.numeric(determinant(P2,logarithm = TRUE)$modulus),
# Response
ranks = as.integer(data$ranks),
cens = as.integer(data$cens),
# Prior params
u = RW2_control$u,
alpha = RW2_control$alpha
)
tmbparams <- list(
W = rep(0, ncol(B2)),
theta = 0
)
ff <- TMB::MakeADFun(
data = c(model = "smooth", tmbdat),
parameters = tmbparams,
random = "W",
DLL = "abcoxp_TMBExports",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
return(ff)
# AGHQ
quad <- aghq::marginal_laplace_tmb(ff, k = Inference_control$aghq_k, c(0))
}
else{
stop("Model does not have a TMB template yet, need to manually implement.")
}
}
a <- abcoxp(data = Leuk, times = "time", cens = "cens", fixed = "age", RW2 = "tpi")
library(abcoxp)
a <- abcoxp(data = Leuk, times = "time", cens = "cens", fixed = "age", RW2 = "tpi")
plot(a)
